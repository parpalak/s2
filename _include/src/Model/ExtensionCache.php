<?php
/**
 * Cache functions for extensions.
 *
 * This file contains the functions used to generate the cache files used for extension system.
 *
 * @copyright 2009-2025 Roman Parpalak
 * @license   https://opensource.org/license/mit MIT
 * @package   S2
 */

declare(strict_types=1);

namespace S2\Cms\Model;

use S2\Cms\Framework\Exception\ConfigurationException;
use S2\Cms\Pdo\DbLayer;
use S2\Cms\Pdo\DbLayerException;

class ExtensionCache
{
    public function __construct(
        private readonly DbLayer $dbLayer,
        private readonly bool    $disableCache,
        private readonly string  $cacheDir,
    ) {
    }

    public const CACHE_ENABLED_EXTENSIONS_FILENAME = 'cache_enabled_extensions.php';

    /**
     * Delete every .php cache file in the cache directory
     */
    public function clear(): void
    {
        $file_list = [
            // Deprecated. Remove when all values are accessed through DynamicConfigProvider
            $this->cacheDir . self::CACHE_ENABLED_EXTENSIONS_FILENAME,
            $this->getCachedRoutesFilename(),
        ];

        foreach ($file_list as $entry) {
            if (file_exists($entry)) {
                @unlink($entry);
            }
        }
    }

    /**
     * Retrieves Extension class names if they exist for enabled extensions.
     *
     * @throws DbLayerException
     */
    public function generateEnabledExtensionClassNames(): array
    {
        $result = $this->dbLayer->buildAndQuery([
            'SELECT' => 'id',
            'FROM'   => 'extensions',
            'WHERE'  => 'disabled = 0',
        ]);

        $extensionClassNames = ['cms' => [], 'admin' => []];
        while ($extension = $this->dbLayer->fetchAssoc($result)) {
            $className = \sprintf('\s2_extensions\%s\Extension', $extension['id']);
            if (class_exists($className)) {
                $extensionClassNames['cms'][] = $className;
            }
            $className = \sprintf('\s2_extensions\%s\AdminExtension', $extension['id']);
            if (class_exists($className)) {
                $extensionClassNames['admin'][] = $className;
            }
        }

        if ($this->disableCache) {
            return $extensionClassNames;
        }

        // Output extension class names as PHP code
        try {
            s2_overwrite_file_skip_locked(
                $this->cacheDir . self::CACHE_ENABLED_EXTENSIONS_FILENAME,
                "<?php\n\n// This file is automatically generated by S2. Do not edit!\n\nreturn " . var_export($extensionClassNames, true) . ';'
            );
            if (\function_exists('opcache_invalidate')) {
                opcache_invalidate($this->cacheDir . self::CACHE_ENABLED_EXTENSIONS_FILENAME, true);
            }
        } catch (\RuntimeException $e) {
            throw new ConfigurationException(\sprintf(
                'Unable to write extensions cache file to cache directory. Please make sure PHP has write access to the directory "%s".',
                $this->cacheDir
            ), null, $e);
        }

        return $extensionClassNames;
    }

    public function clearRoutesCache(): void
    {
        @unlink($this->getCachedRoutesFilename());
    }

    public function getCachedRoutesFilename(): string
    {
        return $this->cacheDir . 'cache_routes.php';
    }
}
